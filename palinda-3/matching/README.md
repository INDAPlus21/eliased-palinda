## What happens if you remove the go-command from the Seek call in the main function?
It finishes the loop first before it goes into any Seek() functions without `go` (probably because it's so quick to create threads). If you remove `go` the different Seek()s are executed synchronously, so it sends, then the next one receives, then the next one sends, etc. And it's always "Anna", then "Bob", etc in order, instead of different names each time. 

If you want you can read my incorrect stream-of-thought reasoning it's below (well, then you'd have to go to developer tools (or just to the markdown file directly), because the html comment tags comment it out): 
<!-- It finishes all in the loop first, but the "in select" call seems to delay (probably because the for loop/thread creating is faster than the log call). So my prediction is that it only calls one Seek(), and not one for each name. Then the program gets "stuck" and never continous past the for loop.
Not exactly.The select statement/reading from the channel is not a blocking operation, so the program continues even if there is a non-seperate-threaded for-loop now listening for the channel in the background. I wonder what the golang implementation of it is. If it uses a javascript-like event loop or just (without telling us/being explicit in the code) creates a separate thread. It goes into the select statement and starts listening to the channels one by one if you remove the "go". It's different names each time regardless, because of the... asynchronous nature it's a bit random. `match` is a channel, and it looks like a memory address when you try to print it out. Nothing about waitgroups seem to be affected. Wait blocks until the waitgroup counter is 0 (meaning until all the Seek() are finished)). Which also seem to correspond to the logging. The first Seek() call is ended immediately because no other is "alive", to send to the channel... no, because AHA it sends its name to match (the first one), then the next one is reading it. ok. now I understand what the go does. it isn't actually continuing to listen in the background. If I add "Elias" I will receive the last person's message.  --> 

## What happens if you switch the declaration wg := new(sync.WaitGroup) to var wg sync.WaitGroup and the parameter wg *sync.WaitGroup to wg sync.WaitGroup?
I get a "fatal error: all goroutines are asleep - deadlock!" instead of "no one received Anna's message". It happens because the wg is not passed by reference anymore. The waitgroup counter isn't reduced/decremented (it's a unique wg object in each Seek() â€” the wg object is [0 5 0] every time, even after wg.Done() is called).  

## What happens if you remove the buffer on the channel match? 
I immediately get "fatal error: all goroutines are asleep - deadlock!". Without a buffer it's UNbuffered (obviously), and only accepts sends if there is a receiver that isn't done/asleep. The last person that tries to send has no receiving goroutines that are alive.

## What happens if you remove the default-case from the case-statement in the main function? 
Nothing, because it never goes into the default regardless (because there is always one that doesn't receive the message, because the number of people is odd). If I add "Elias" it *will* go into the default. (Tested it, and it was a correct assumption). 

<!--Looking in the documentation is really useful: `select with a default clause to implement non-blocking sends, receives, and even non-blocking multi-way selects.` (but didn't matter for the rest of the program because it was in goroutines regardless). But if you take a default case... and remove the case match <- name.  
 select is SPECIFIC for channels (doesn't have any other function in the language, and it can have two cases that both execute)
RPC = remote procedure call -->