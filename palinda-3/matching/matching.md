# What happens if you remove the go-command from the Seek call in the main function?
Because reading from a channel is a blocking operation. No. Because the waitgroup. Nothing, it seems like... 
So it doesn't even wait for the for loop to be "done" (with the log statements?)
What if you log... 
No. It finishes all in the loop first, but the "in select" call seems to delay (probably because the for loop/thread creating is faster than the log call)
So my prediction is that it only calls one Seek(), and not one for each name. Then the program gets "stuck" and never continous past the for loop.
Not exactly. The select statement/reading from the channel is not a blocking operation, so the program continues even if there is a non-seperate-threaded for-loop now listening for the channel in the background. I wonder what the golang implementation of it is. If it uses a javascript-like event loop or just (without telling us/being explicit in the code) creates a separate thread. It goes into the select statement and starts listening to the channels one by one if you remove the "go". It's different names each time regardless, because of the... asynchronous nature it's a bit random. `match` is a channel, and it looks like a memory address when you try to print it out. Nothing about waitgroups seem to be affected. Wait blocks until the waitgroup counter is 0 (meaning until all the Seek() are finished)). Which also seem to correspond to the logging. The first Seek() call is ended immediately because no other is "alive", to send to the channel... no, because AHA it sends its name to match (the first one), then the next one is reading it. ok. now I understand what the go does. it isn't actually continuing to listen in the background. If I add "Elias" I will receive the last person's message.  

# What happens if you switch the declaration wg := new(sync.WaitGroup) to var wg sync.WaitGroup and the parameter wg *sync.WaitGroup to wg sync.WaitGroup?
I get a "fatal error: all goroutines are asleep - deadlock!" instead of "no one received anna's message" (it's not passed by reference anymore). Yes. The waitgroup counter isn't reduced/decremented (it's a unique wg object for each in Seek() function call) (the wg object is [0 5 0] every time, even after wg.Done() is called).Or no, that actually happens either way. Yes it should actually be decremented. 

# What happens if you remove the buffer on the channel match? 
I immediately get "fatal error: all goroutines are asleep - deadlock!". Without a buffer it's UNbuffered (obviously), only accepts sends if there is a receiver. So this error is probably caused by that it doesn't accept a send because all are asleep. Yes. "Dave" tries to send one without any alive goroutines. 
From documentation: `Buffered channels accept a limited number of values without a corresponding receiver for those values.` 

# What happens if you remove the default-case from the case-statement in the main function? 
select is SPECIFIC for channels (doesn't have any other function in the language, and it can have two cases that both execute) 
RPC = remote procedure call 
Nothing, because it never goes into the default regardless (because there is always one that doesn't receive the message, because the number of people is odd). If I add "Elias" it *will* go into the default. Correct assumption. Looking in the documentation is really useful: `select with a default clause to implement non-blocking sends, receives, and even non-blocking multi-way selects.` (but didn't matter for the rest of the program because it was in goroutines regardless). But if you take a default case... and remove the case match <- name.  